<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tilt Instrument</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Teko:wght@500&display=swap');

        :root {
            --bg-color: #6f4e37;
            --key-color: #fdf6e3;
            --text-color: #4a2c2a;
            --accent-color: #ffc107;
            --active-color: #e74c3c;
        }

        body {
            font-family: 'Teko', sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: var(--bg-color);
            -webkit-tap-highlight-color: transparent;
            overflow: hidden;
        }

        .instrument-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px;
        }

        .motion-controls {
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        #motion-toggle, #calibrate-btn {
            padding: 15px 30px;
            font-size: 1.5rem;
            font-family: 'Teko', sans-serif;
            border-radius: 10px;
            border: 3px solid var(--text-color);
            background-color: var(--key-color);
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #motion-toggle.active {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        #calibrate-btn {
            display: none; /* Hidden by default */
        }
        
        #calibrate-btn:active {
            transform: scale(0.95);
        }


        .keyboard-area {
            flex-grow: 1;
            display: flex;
            gap: 20px;
        }
        
        .key {
            flex-grow: 1;
            border-radius: 15px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
            user-select: none;
            transition: all 0.1s ease;
            background: var(--key-color);
            border: 2px solid rgba(0,0,0,0.2);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            font-size: 5rem;
            color: var(--text-color);
        }
        
        .key.active {
            background: var(--accent-color);
            transform: scale(0.98);
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>

    <div class="instrument-container">
        <div class="motion-controls">
            <button id="motion-toggle">Enable Motion</button>
            <button id="calibrate-btn">Calibrate</button>
        </div>
        <div class="keyboard-area">
            <div class="key" id="key-sa" data-interval="0">Sa</div>
            <div class="key" id="key-pa" data-interval="7">Pa</div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- Basic Setup ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;

    // DOM Elements
    const motionToggle = document.getElementById('motion-toggle');
    const calibrateBtn = document.getElementById('calibrate-btn');
    const keySa = document.getElementById('key-sa');
    const keyPa = document.getElementById('key-pa');
    const keyboardArea = document.querySelector('.keyboard-area');

    // State
    let activeNotes = {};
    let isTiltModeActive = false;
    let currentTiltNoteIndex = 0;
    
    // Calibration and Smoothing State
    let calibrationOffset = 0;
    let tiltHistory = [];
    const TILT_HISTORY_LENGTH = 5; // Average over last 5 readings for smoothness

    // --- Sound Definitions ---
    const TONE_SETTINGS = { name: 'Harmonium', type: 'sawtooth', detune: 3, vol: 0.4 };
    const KEY_MAP = { 'C4': 523.25, 'C#4': 554.37, 'D4': 587.33, 'D#4': 622.25, 'E4': 659.25, 'F4': 698.46, 'F#4': 739.99, 'G4': 783.99, 'G#4': 830.61, 'A4': 880.00, 'A#4': 932.33, 'B4': 987.77, 'C5': 1046.50 };
    const CHROMATIC_SCALE = Object.keys(KEY_MAP);

    // --- Audio Initialization ---
    function initAudio() {
        if (!audioCtx) {
            try {
                audioCtx = new AudioContext();
            } catch(e) {
                alert('Web Audio API is not supported in this browser.');
            }
        }
    }

    // --- Sound Generation ---
    function playNote(baseNote) {
        if (!audioCtx || activeNotes[baseNote]) return;
        
        const freq = KEY_MAP[baseNote];
        if (!freq) return;

        const now = audioCtx.currentTime;
        const gainNode = audioCtx.createGain();
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(TONE_SETTINGS.vol, now + 0.02);
        gainNode.connect(audioCtx.destination);
        
        const osc1 = audioCtx.createOscillator();
        osc1.type = TONE_SETTINGS.type;
        osc1.frequency.setValueAtTime(freq, now);
        osc1.connect(gainNode);
        
        const osc2 = audioCtx.createOscillator();
        osc2.type = TONE_SETTINGS.type;
        osc2.frequency.setValueAtTime(freq, now);
        osc2.detune.setValueAtTime(TONE_SETTINGS.detune, now);
        osc2.connect(gainNode);
        
        osc1.start(now);
        osc2.start(now);

        activeNotes[baseNote] = { osc1, osc2, gainNode };
    }

    function stopNote(baseNote) {
        if (!activeNotes[baseNote]) return;
        const { osc1, osc2, gainNode } = activeNotes[baseNote];
        const now = audioCtx.currentTime;
        gainNode.gain.cancelScheduledValues(now);
        gainNode.gain.setValueAtTime(gainNode.gain.value, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
        osc1.stop(now + 0.1);
        osc2.stop(now + 0.1);
        delete activeNotes[baseNote];
    }
    
    // --- Event Listeners & Logic ---
    function handleNoteOn(keyElement) {
        initAudio();
        // **FIX for iOS**: Resume audio context if it's suspended
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }

        const baseNote = CHROMATIC_SCALE[currentTiltNoteIndex];
        const interval = parseInt(keyElement.dataset.interval || 0);
        const baseIndex = CHROMATIC_SCALE.indexOf(baseNote);
        const finalNote = CHROMATIC_SCALE[baseIndex + interval];
        
        if (finalNote) {
            keyElement.classList.add('active');
            playNote(finalNote);
            // Use the key's ID to track which sound is playing
            activeNotes[keyElement.id] = finalNote;
        }
    }

    function handleNoteOff(keyElement) {
        const noteToStop = activeNotes[keyElement.id];
        if (noteToStop) {
            keyElement.classList.remove('active');
            stopNote(noteToStop);
            delete activeNotes[keyElement.id];
        }
    }
    
    // --- REVISED Event Handlers for Multi-touch ---
    const activeTouches = {}; // To track which touch is on which key

    keyboardArea.addEventListener('mousedown', e => {
        if (e.target.classList.contains('key')) {
            handleNoteOn(e.target);
        }
    });
    keyboardArea.addEventListener('mouseup', e => {
        if (e.target.classList.contains('key')) {
            handleNoteOff(e.target);
        }
    });
    keyboardArea.addEventListener('mouseleave', e => {
        // Stop all notes if mouse leaves the area
        document.querySelectorAll('.key.active').forEach(handleNoteOff);
    });

    keyboardArea.addEventListener('touchstart', e => {
        e.preventDefault();
        [...e.changedTouches].forEach(touch => {
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            if (target && target.classList.contains('key')) {
                handleNoteOn(target);
                activeTouches[touch.identifier] = target;
            }
        });
    }, { passive: false });

    keyboardArea.addEventListener('touchend', e => {
        e.preventDefault();
        [...e.changedTouches].forEach(touch => {
            const target = activeTouches[touch.identifier];
            if (target) {
                handleNoteOff(target);
                delete activeTouches[touch.identifier];
            }
        });
    }, { passive: false });


    // --- Tilt Control Logic ---
    function requestMotionPermission() {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission().then(permissionState => {
                if (permissionState === 'granted') {
                    window.addEventListener('devicemotion', handleDeviceMotion);
                } else {
                    alert('Permission for motion sensors was not granted.');
                    isTiltModeActive = false;
                    motionToggle.classList.remove('active');
                    motionToggle.textContent = 'Enable Motion';
                    calibrateBtn.style.display = 'none';
                }
            }).catch(console.error);
        } else {
            window.addEventListener('devicemotion', handleDeviceMotion);
        }
    }
    
    function handleDeviceMotion(event) {
        if (!isTiltModeActive || !event.accelerationIncludingGravity.x) return;
        
        const rawX = event.accelerationIncludingGravity.x - calibrationOffset;
        
        tiltHistory.push(rawX);
        if (tiltHistory.length > TILT_HISTORY_LENGTH) {
            tiltHistory.shift();
        }
        
        const smoothedX = tiltHistory.reduce((a, b) => a + b, 0) / tiltHistory.length;

        const tiltRatio = Math.max(-1, Math.min(1, smoothedX / 10));
        const noteIndex = Math.round((( -tiltRatio + 1) / 2) * (CHROMATIC_SCALE.length - 1));
        
        if (noteIndex !== currentTiltNoteIndex) {
            currentTiltNoteIndex = noteIndex;
            updateKeyLabels();
        }
    }

    function updateKeyLabels() {
        const saNote = CHROMATIC_SCALE[currentTiltNoteIndex];
        const paIndex = currentTiltNoteIndex + 7;
        const paNote = paIndex < CHROMATIC_SCALE.length ? CHROMATIC_SCALE[paIndex] : '-';
        
        keySa.textContent = saNote.replace('#', '♯');
        keyPa.textContent = paNote.replace('#', '♯');
    }
    
    function handleCalibration() {
        const handleCalibrationEvent = (event) => {
            if (event.accelerationIncludingGravity.x) {
                calibrationOffset = event.accelerationIncludingGravity.x;
                window.removeEventListener('devicemotion', handleCalibrationEvent);
                
                const originalText = calibrateBtn.textContent;
                calibrateBtn.textContent = 'Calibrated!';
                setTimeout(() => {
                    calibrateBtn.textContent = originalText;
                }, 1000);
            }
        };
        window.addEventListener('devicemotion', handleCalibrationEvent);
    }

    motionToggle.addEventListener('click', () => {
        isTiltModeActive = !isTiltModeActive;
        if (isTiltModeActive) {
            initAudio();
            requestMotionPermission();
            motionToggle.classList.add('active');
            motionToggle.textContent = 'Motion Enabled';
            calibrateBtn.style.display = 'inline-block';
        } else {
            motionToggle.classList.remove('active');
            motionToggle.textContent = 'Enable Motion';
            calibrateBtn.style.display = 'none';
            keySa.textContent = 'Sa';
            keyPa.textContent = 'Pa';
            calibrationOffset = 0;
            tiltHistory = [];
        }
    });
    
    calibrateBtn.addEventListener('click', handleCalibration);
});
</script>
</body>
</html>

